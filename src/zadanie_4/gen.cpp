#include "zadanie_4/gen.hpp"

#include "util.hpp"
#include "zadanie_1/nn.hpp"

#include <compare>
#include <optional>
#include <random>
#include <set>
#include <utility>
#include <variant>
#include <vector>

namespace gen::impl {

struct Chromosome {
  std::vector<int> vertices;
  std::vector<int> path;
  int              cost;

  constexpr std::weak_ordering operator<=>(
  const Chromosome& other) const noexcept {
    // if can compare cost return that, else fallback to bad but fast hash

    if (const auto result = cost <=> other.cost;
        result != std::strong_ordering::equal) {
      return result;
    }

    if (const auto result = path.at(0) <=> other.path.at(0);
        result != std::strong_ordering::equal) {
      return result;
    }

    if (const auto result = path.at(1) <=> other.path.at(1);
        result != std::strong_ordering::equal) {
      return result;
    }

    return path.at(path.size() / 2) <=> other.path.at(other.path.size() / 2);
  }
};

// population is always sorted by cost
using Population = std::set<Chromosome>;

[[nodiscard]] static std::variant<Population, tsp::ErrorAlgorithm>
init_population(const tsp::Matrix<int>&   matrix,
                const tsp::GraphInfo&     graph_info,
                const std::optional<int>& optimal_cost,
                auto&                     rand_src,
                int                       population_count) noexcept {
  const int v_count {static_cast<int>(matrix.size())};

  auto nn_result {nn::run(matrix, graph_info, optimal_cost)};
  if (std::holds_alternative<tsp::ErrorAlgorithm>(nn_result)) [[unlikely]] {
    return std::get<tsp::ErrorAlgorithm>(nn_result);
  }

  const Chromosome nn_chromosome {[&nn_result, &v_count]() noexcept {
    tsp::Solution nn_solution {std::move(std::get<tsp::Solution>(nn_result))};

    std::vector vertices(v_count, -1);
    for (int i {0}; i < v_count; ++i) {
      vertices.at(nn_solution.path.at(i)) = i;
    }

    return Chromosome {.vertices = std::move(vertices),
                       .path     = std::move(nn_solution.path),
                       .cost     = nn_solution.cost};
  }()};

  // first chromosome is always the nn solution
  Population population {{nn_chromosome}};

  // the next chromosomes are generated by swapping two random vertices in the nn solution
  std::uniform_int_distribution dist {1, v_count - 1};
  while (population.size() != population_count) [[likely]] {
    const int first_idx {dist(rand_src)};
    const int second_idx {dist(rand_src)};

    const auto first_v {nn_chromosome.path.at(first_idx)};
    const auto second_v {nn_chromosome.path.at(second_idx)};

    const int first_new_cost_left {
      matrix.at(nn_chromosome.path.at(second_idx - 1)).at(first_v)};
    const int first_new_cost_right {
      matrix.at(first_v).at(nn_chromosome.path.at(second_idx + 1))};
    const int second_new_cost_left {
      matrix.at(nn_chromosome.path.at(first_idx - 1)).at(second_v)};
    const int second_new_cost_right {
      matrix.at(second_v).at(nn_chromosome.path.at(first_idx + 1))};

    if (first_new_cost_left == -1 || first_new_cost_right == -1 ||
        second_new_cost_left == -1 || second_new_cost_right == -1)
    [[unlikely]] {
      continue;
    }

    const int old_cost {
      matrix.at(nn_chromosome.path.at(first_idx - 1)).at(first_v) +
      matrix.at(first_v).at(nn_chromosome.path.at(first_idx + 1)) +
      matrix.at(nn_chromosome.path.at(second_idx - 1)).at(second_v) +
      matrix.at(second_v).at(nn_chromosome.path.at(second_idx + 1))};

    const int cost_diff {first_new_cost_left + first_new_cost_right +
                         second_new_cost_left + second_new_cost_right -
                         old_cost};

    population.emplace([&nn_chromosome,
                        &first_v,
                        &first_idx,
                        &second_v,
                        &second_idx,
                        &cost_diff]() noexcept {
      Chromosome chromosome {.vertices = nn_chromosome.vertices,
                             .path     = nn_chromosome.path,
                             .cost     = nn_chromosome.cost + cost_diff};

      std::swap(chromosome.path.at(first_idx), chromosome.path.at(second_idx));
      std::swap(chromosome.vertices.at(first_v),
                chromosome.vertices.at(second_v));

      return chromosome;
    }());
  }

  return population;
}

[[nodiscard]] static std::optional<Chromosome> crossover(
const tsp::Matrix<int>& matrix,
auto&                   rand_src,
const Chromosome&       parent_base,
const Chromosome&       parent2,
int                     max_v_count_crossover) noexcept {
  // crossover is done by selecting a random vertex from the first parent and
  // then selecting a random number of vertices from the second parent to
  // replace the selected vertex and its subsequent vertices in the first parent,
  // invalid crossovers are discarded

  const int v_count {static_cast<int>(matrix.size())};

  Chromosome child {.vertices = parent_base.vertices,
                    .path     = parent_base.path,
                    .cost     = parent_base.cost};

  std::uniform_int_distribution dist {};

  const int first_idx {
    dist(rand_src,
         std::uniform_int_distribution<>::param_type {1, v_count - 1})};
  const auto first_v {child.path.at(first_idx)};

  const auto second_idx {parent2.vertices.at(first_v)};

  const auto count {dist(
  rand_src,
  std::uniform_int_distribution<>::param_type {
    1,
    std::min(
    {v_count - second_idx, v_count - first_idx, max_v_count_crossover})})};

  for (int i {1}; i < count; ++i) {
    const int base_idx {first_idx + i};
    const int other_idx {second_idx + i};

    const int base_v {child.path.at(base_idx)};
    const int other_v {parent2.path.at(other_idx)};

    if (base_v == other_v) [[unlikely]] {
      continue;
    }

    if (child.vertices.at(other_v) < first_idx ||
        child.vertices.at(other_v) >= first_idx + count) {
      return std::nullopt;
    }

    const int new_cost_left {
      matrix.at(child.path.at(base_idx - 1)).at(other_v)};
    const int new_cost_right {
      matrix.at(other_v).at(child.path.at(base_idx + 1))};

    if (new_cost_left == -1 || new_cost_right == -1) [[unlikely]] {
      return std::nullopt;
    }

    const int old_cost {matrix.at(child.path.at(base_idx - 1)).at(base_v) +
                        matrix.at(base_v).at(child.path.at(base_idx + 1))};

    const int cost_diff {new_cost_left + new_cost_right - old_cost};

    child.path.at(base_idx)     = other_v;
    child.vertices.at(other_v)  = base_idx;
    child.cost                 += cost_diff;
  }

  return child;
}

static std::optional<Chromosome> mutate(const tsp::Matrix<int>& matrix,
                                        auto&                   rand_src,
                                        const Chromosome&       base) noexcept {
  // mutation is done by selecting a random vertex and swapping it with the
  // first vertex in the path, invalid mutations are discarded

  const int v_count {static_cast<int>(matrix.size())};

  std::uniform_int_distribution dist {2, v_count - 2};

  const int swap_idx {dist(rand_src)};
  const int swap_v {base.path.at(swap_idx)};
  const int first_v {base.path.at(0)};

  const int new_cost_left_s {matrix.at(base.path.at(v_count - 1)).at(swap_v)};
  const int new_cost_right_s {matrix.at(swap_v).at(base.path.at(1))};

  const int new_cost_left_in {
    matrix.at(base.path.at(swap_idx - 1)).at(first_v)};
  const int new_cost_right_in {
    matrix.at(first_v).at(base.path.at(swap_idx + 1))};

  if (new_cost_left_s == -1 || new_cost_right_s == -1 ||
      new_cost_left_in == -1 || new_cost_right_in == -1) [[unlikely]] {
    return std::nullopt;
  }

  const int old_cost {
    matrix.at(base.path.at(swap_idx - 1)).at(base.path.at(swap_idx)) +
    matrix.at(base.path.at(swap_idx)).at(base.path.at(swap_idx + 1)) +
    matrix.at(base.path.at(v_count - 1)).at(first_v) +
    matrix.at(first_v).at(base.path.at(1))};

  const int cost_diff {new_cost_left_s + new_cost_right_s + new_cost_left_in +
                       new_cost_right_in - old_cost};

  Chromosome new_chromosome {.vertices = base.vertices,
                             .path     = base.path,
                             .cost     = base.cost + cost_diff};

  std::swap(new_chromosome.path.at(swap_idx), new_chromosome.path.at(0));
  new_chromosome.path.at(v_count) = swap_v;
  std::swap(new_chromosome.vertices.at(swap_v),
            new_chromosome.vertices.at(first_v));

  return new_chromosome;
}

static void cut(Population& population, int target_count) noexcept {
  // cut the last chromosomes from the population to match the target count

  population.erase(
  std::ranges::next(population.begin(), target_count, population.end()),
  population.end());
}

static void reproduce(const tsp::Matrix<int>& matrix,
                      auto&                   rand_src,
                      Population&             population,
                      int                     children_per_itr,
                      int                     children_per_pair,
                      int                     max_v_count_crossover) noexcept {
  constexpr static int MAX_RETIRES_PER_OFFSPRING {10};

  std::uniform_int_distribution dist {};

  std::vector<Chromosome> children {};
  children.reserve(children_per_itr);

  // only the first half of the population is used as parent base, the second
  // half is used as second parent
  while (children.size() != children_per_itr) [[likely]] {
    const auto first_parent_itr {
      std::next(population.begin(),
                dist(rand_src,
                     std::uniform_int_distribution<>::param_type {
                       0,
                       static_cast<int>(population.size() / 2)}))};

    const auto second_parent_itr {
      std::prev(population.end(),
                dist(rand_src,
                     std::uniform_int_distribution<>::param_type {
                       1,
                       static_cast<int>(population.size() / 2) - 1}))};

    for (int offspring {0}, attempts {0};
         offspring < children_per_pair &&
         attempts < MAX_RETIRES_PER_OFFSPRING &&
         children.size() < children_per_itr;
         ++attempts) {
      auto child {crossover(matrix,
                            rand_src,
                            *first_parent_itr,
                            *second_parent_itr,
                            max_v_count_crossover)};

      if (child.has_value()) {
        ++offspring;
        attempts = -1;
        children.emplace_back(std::move(child.value()));
      }
    }
  }

  for (auto& child : children) {
    population.emplace(std::move(child));
  }
}

[[nodiscard]] static std::variant<tsp::Solution, tsp::ErrorAlgorithm> algorithm(
const tsp::Matrix<int>&   matrix,
const tsp::GraphInfo&     graph_info,
const std::optional<int>& optimal_cost,
int                       count_of_itr,
int                       population_size,
int                       children_per_itr,
int                       max_children_per_pair,
int                       max_v_count_crossover,
int                       mutations_per_1000) noexcept {
  std::mt19937_64 rand_src {std::random_device {}()};

  auto population_result {init_population(matrix,
                                          graph_info,
                                          optimal_cost,
                                          rand_src,
                                          population_size)};
  if (std::holds_alternative<tsp::ErrorAlgorithm>(population_result))
  [[unlikely]] {
    return std::get<tsp::ErrorAlgorithm>(population_result);
  }

  Population population {std::move(std::get<Population>(population_result))};

  std::uniform_int_distribution mutation_dist {0, 1000};
  std::geometric_distribution   mutated_dist {0.5};

  for (int itr {0}; itr < count_of_itr; ++itr) {
    // if optimal solution is found, end early
    if (population.begin()->cost == optimal_cost) [[unlikely]] {
      break;
    }

    reproduce(matrix,
              rand_src,
              population,
              children_per_itr,
              max_children_per_pair,
              max_v_count_crossover);

    // mutate based on mutation chance, the base is chosen on geometric distribution basis, if mutation is successful add to population
    for (int mutation_chance {0}; mutation_chance < 1000; ++mutation_chance) {
      if (mutation_dist(rand_src) < mutations_per_1000) [[unlikely]] {
        const int to_mutate {std::min(static_cast<int>(population.size() - 1),
                                      mutated_dist(rand_src))};
        if (auto mutated {mutate(matrix,
                                 rand_src,
                                 *std::ranges::next(population.begin(),
                                                    to_mutate,
                                                    population.end()))};
            mutated.has_value()) {
          population.emplace(std::move(mutated.value()));
        }
      }
    }

    cut(population, population_size);
  }

  return tsp::Solution {.path = population.begin()->path,
                        .cost = population.begin()->cost};
}

}    // namespace gen::impl

namespace gen {

[[nodiscard]] std::variant<tsp::Solution, tsp::ErrorAlgorithm> run(
const tsp::Matrix<int>&   matrix,
const tsp::GraphInfo&     graph_info,
const std::optional<int>& optimal_cost,
int                       count_of_itr,
int                       population_size,
int                       children_per_itr,
int                       max_children_per_pair,
int                       max_v_count_crossover,
int                       mutations_per_1000) noexcept {
  if (count_of_itr < 1 || population_size < 2 || children_per_itr < 1 ||
      max_children_per_pair < 1 || mutations_per_1000 < 0 ||
      mutations_per_1000 > 1000) [[unlikely]] {
    return tsp::ErrorAlgorithm::INVALID_PARAM;
  }

  if (matrix.empty()) [[unlikely]] {    // edge case: no vertices
    return tsp::ErrorAlgorithm::NO_PATH;
  }

  if (matrix.size() == 1) [[unlikely]] {    // edge case: 1 vertex
    return tsp::Solution {.path = {0}, .cost = 0};
  }

  if (matrix.size() == 2) [[unlikely]] {    // edge case: 2 vertices
    return nn::run(matrix, graph_info, optimal_cost);
  }

  return impl::algorithm(matrix,
                         graph_info,
                         optimal_cost,
                         count_of_itr,
                         population_size,
                         children_per_itr,
                         max_children_per_pair,
                         max_v_count_crossover,
                         mutations_per_1000);
}

}    // namespace gen
